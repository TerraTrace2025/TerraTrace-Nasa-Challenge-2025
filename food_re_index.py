# -*- coding: utf-8 -*-
"""food_re_index

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PVtYxmKUGSKIzjV9mnjoi6WByGPW4uCH
"""

# !pip install geocoder
# !pip install meteostat
# !pip install geopandas
# !pip install osmnx

import os
import requests
from datetime import datetime, timedelta, date
import pandas as pd
from meteostat import Point, Daily
from google.colab import files
import geocoder
from geopy.geocoders import Nominatim
from tqdm import tqdm
import geopandas as gpd
import osmnx as ox
from shapely.geometry import Point

"""***Input*** ***1: Crop Information: Names & Locations***"""

df = pd.read_excel("harvest_locations.xlsx", skiprows=1)

# state_location = df["Kt."]
# origin_location = df["Standort"]
crop_names = df.columns[7:].tolist()

mapping = {
    'Brotweizen': 'Wheat',
    'Umstellmahlweizen': 'Wheat',
    'Futterweizen': 'Wheat',
    'Futtergerste': 'Barley',
    'Körnermais': 'Corn',
    'Sojabohnen Futter': 'Soybean',
    'Sojabohnen "Tofu"': 'Soybean',
    'Raps Kl.': 'Rapeseed',
    'Raps HOLL': 'Rapeseed',
    'Sonnenblumen lino': 'Sunflowerseed',
    'Sonnenblumen HO': 'Sunflowerseed'
}


swiss_crop = [crop for crop in crop_names if crop in mapping]

locations_dict = {}

for crop in swiss_crop:
    category = mapping[crop]  # 找到大类
    crop_locations = df.loc[df[crop] == "x", "Standort"].tolist()

    if category not in locations_dict:
        locations_dict[category] = crop_locations
    else:
        locations_dict[category] = list(set(locations_dict[category] + crop_locations))


for k, v in locations_dict.items():
    print(f"{k}: {v}")
    print(f"{k}: {len(v)} locations")

geolocator = Nominatim(user_agent="geoapi", timeout=10)

cache = {}

def clean_location(address):
    address = address.replace("b.", "bei")
    if "(FL)" in address:
        address = address.replace("(FL)", "").strip()
        country = "Liechtenstein"
    else:
        country = "Switzerland"
    return address, country

def get_lat_lon_cached(address):
    if address in cache:
        return cache[address]

    try:
        clean_addr, country = clean_location(address)
        location = geolocator.geocode(f"{clean_addr}, {country}")
        if location:
            result = (location.latitude, location.longitude)
        else:
            result = (None, None)
    except:
        result = (None, None)

    manual_fix = {
        "3292 Busswil bei Büren": (47.133, 7.246),
        "9494 Schaan": (47.166, 9.516)
    }
    if result == (None, None) and clean_addr in manual_fix:
        result = manual_fix[clean_addr]

    cache[address] = result
    return result

category_coords = {}
for category, locations in locations_dict.items():
    print(f"Processing {category}...")
    coords_list = []
    for loc in tqdm(locations):
        lat, lon = get_lat_lon_cached(loc)
        coords_list.append([loc, lat, lon])
    category_coords[category] = pd.DataFrame(coords_list, columns=["Standort", "Latitude", "Longitude"])

wheat_loc = category_coords["Wheat"]
barley_loc = category_coords["Barley"]
corn_loc = category_coords["Corn"]
soy_loc = category_coords["Soybean"]
rap_loc = category_coords["Rapeseed"]
sun_loc = category_coords["Sunflowerseed"]

print(wheat_loc)
for i in wheat_loc:
  print(i)
  print(type(i))

"""***Input 2: Climate Data***

* Location
"""

latitude = 47.3341488
longitude = 8.0216498

"""* Historical and future weather forecast"""

def get_historical_weather(start_date_str, end_date_str):
    """
    Fetch historical daily weather (ERA5).
    ERA5 typically has ~5 days delay, so yesterday is not available.
    """
    ERA5_URL = "https://archive-api.open-meteo.com/v1/era5"

    # Adjust end_date if too recent
    today = date.today()
    max_available = today - timedelta(days=5)
    end_date = min(datetime.strptime(end_date_str, "%Y-%m-%d").date(), max_available)
    start_date = datetime.strptime(start_date_str, "%Y-%m-%d").date()

    if start_date > end_date:
        raise ValueError("Start date is after available end date.")

    daily_vars = ",".join([
        "temperature_2m_max","temperature_2m_min","precipitation_sum",
        "windspeed_10m_max","windgusts_10m_max","shortwave_radiation_sum",
        "snowfall_sum"
    ])

    params = {
        "latitude": latitude,
        "longitude": longitude,
        "start_date": start_date.isoformat(),
        "end_date": end_date.isoformat(),
        "daily": daily_vars,
        "timezone": "Europe/Zurich"
    }
    resp = requests.get(ERA5_URL, params=params)
    if resp.status_code == 200:
        df = pd.DataFrame(resp.json()["daily"])
        # Simplified weathercode
        df["weathercode"] = df.apply(lambda row:
                                     "snow" if row.get("snowfall_sum",0)>0 else
                                     "rain" if row["precipitation_sum"]>5 else
                                     "showers/windy" if row["precipitation_sum"]>0 and row["windspeed_10m_max"]>10 else
                                     "sunny" if row["shortwave_radiation_sum"]>15000 else "cloudy",
                                     axis=1)
        return df
    else:
        print("Historical request failed:", resp.status_code)
        return None

def get_forecast_weather(n_days):
    """
    Fetch forecast daily weather for the next n_days.
    Converts official weathercode to simplified types like historical data.
    """
    FORECAST_URL = "https://api.open-meteo.com/v1/forecast"
    start_date = date.today()
    end_date = start_date + timedelta(days=n_days-1)

    daily_vars = [
        "temperature_2m_max","temperature_2m_min",
        "precipitation_sum","windspeed_10m_max",
        "weathercode","snowfall_sum"
    ]

    params = {
        "latitude": latitude,
        "longitude": longitude,
        "daily": ",".join(daily_vars),
        "start_date": start_date.isoformat(),
        "end_date": end_date.isoformat(),
        "timezone": "Europe/Zurich"
    }
    resp = requests.get(FORECAST_URL, params=params)
    if resp.status_code == 200:
        df = pd.DataFrame(resp.json()["daily"])

        # map official weathercode to simplified types
        def code_to_simple(wc, precip, wind, snow):
            if snow > 0:
                return "snow"
            elif precip > 5:
                return "rain"
            elif precip > 0 and wind > 10:
                return "showers/windy"
            elif wc in [0,1,2]:  # clear/sunny codes
                return "sunny"
            else:
                return "cloudy"

        df["weathercode"] = df.apply(lambda row: code_to_simple(
            row["weathercode"], row["precipitation_sum"], row["windspeed_10m_max"], row.get("snowfall_sum",0)
        ), axis=1)
        return df
    else:
        print("Forecast request failed:", resp.status_code)
        return None

print("=== Historical Weather ===")
try:
    hist_df = get_historical_weather("2025-09-15", "2025-09-28")
    if hist_df is not None:
        print(hist_df)
except Exception as e:
    print("Historical weather fetch error:", e)

# ===============================
# Test forecast weather
# ===============================
print("\n=== Forecast Weather ===")
try:
    fc_df = get_forecast_weather(5)  # next 5 days
    if fc_df is not None:
        print(fc_df)
except Exception as e:
    print("Forecast weather fetch error:", e)

"""***Input 3: Yield Data (Optional but Recommended)***"""

df = pd.read_csv("FAOSTAT_data.csv")

keywords = ["Wheat", "Barley", "Corn", "Soya", "Rapeseed", "Sunflower"]

mask = df["Item"].str.contains('|'.join(keywords), case=False, na=False)
df_filtered = df[mask]
columns_to_keep = ["Area", "Item", "Year", "Unit", "Value"]
df_filtered = df_filtered[columns_to_keep]
print(df_filtered)

"""***Input 4: Administrative or grid boundaries (crop location)***

"""

gdf = gpd.read_file("gadm41_CHE_3.shp")
point = Point(7.187919, 46.849259)
region = gdf[gdf.geometry.contains(point)]
print(region)

